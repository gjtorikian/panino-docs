<!DOCTYPE html><!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]> <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]> <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]--><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Node.js Manual TEST - </title><meta name="generator" content="panino-doc-build"><meta name="author" content="Garen J. Torikian"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="./assets/csses/bootstrap.min.css"><link rel="stylesheet" href="./assets/csses/prettify.css"><link rel="stylesheet" href="./assets/csses/refguide_overrides.css"><link href="./assets/images/favicon.ico" rel="icon" type="image/x-icon"><link type="text/css" rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/vs.min.css"><script src="./assets/javascripts/jquery.js"></script><script src="./assets/javascripts/clicker.js"></script><script src="./assets/javascripts/jquery.collapse.js"></script><script src="./assets/javascripts/jquery.cookie.js"></script><script src="./assets/javascripts/bootstrap-dropdown.js"></script><script src="./assets/javascripts/jquery-scrollspy.js"></script><script src="./assets/javascripts/prettify-extension.js"></script></head><body><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div id="topSection" class="container"><ul class="nav topLinks"></ul><form id="searchbox" action="" class="navbar-search pull-right"> <input name="query" type="text" placeholder="Search the API" title="Search across all the documentation" class="search-query span3"></form></div></div></div><div id="nonFooter"><div id="wrapper"><div class="content"><div class="row centerpiece"><div id="sidebarContainer" class="span3"><div id="sidebar"><!--include _menu.jade--></div></div><div id="mainContent" class="span9"><div id="documentation"><div class="classContent"><div class="membersBackground"></div><div class=" members pos0"><div class=" membersContent pos0"><h1 class="memberHeader"><span class="name">Addons</span></h1><ul data-tabs="tabs" class="nav tabs pos0"><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li></ul></div></div><article id="Addons" data-title="Addons (class)" class="article"><div class="section description"><div class="memberContent"><p>Addons are dynamically linked shared objects. They can provide glue to C and
C++ libraries. The API (at the moment) is rather complex, involving
knowledge of several libraries:</p>
<ul>
<li><p>V8 Javascript, a C++ library. Used for interfacing with Javascript:
creating objects, calling functions, etc. These are documented mostly in
the <code>v8.h</code> header file (<code>deps/v8/include/v8.h</code> in the Node.js source tree),
and also available <a href="http://izs.me/v8-docs/main.html">online</a>.</p>
</li>
<li><p><a href="https://github.com/joyent/libuv">libuv</a>, a C event loop library. Anytime
one needs to wait for a file descriptor to become readable, wait for a timer,
or wait for a signal to received one needs to interface with libuv. That is,
if you perform  any I/O, libuv needs to be used.</p>
</li>
<li><p>Internal Node libraries. Most importantly is the <code>node::ObjectWrap</code> class
which you will likely want to derive from.</p>
</li>
<li><p>Additional libraries are located the <code>deps/</code> folder.</p>
</li>
</ul>
<p>Node.js statically compiles all its dependencies into the executable. When
compiling  your module, you don&#39;t need to worry about linking to any of these
libraries.</p>
<p>First, let&#39;s make a small Addon which is the C++ equivalent of the following
Javascript code:</p>
<pre><code>exports.hello = <span class="keyword">function</span>() { <span class="keyword">return</span> <span class="string">'world'</span>; };</code></pre>
<p>To get started, we&#39;ll create a file <code>hello.cc</code>:</p>
<pre><code><span class="preprocessor">#include &lt;node.h></span>
<span class="preprocessor">#include &lt;v8.h></span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">Method</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;
  <span class="keyword">return</span> scope.Close(String::New(<span class="string">"world"</span>));
}

<span class="keyword">void</span> init(Handle&lt;<span class="built_in">Object</span>> target) {
  NODE_SET_METHOD(target, <span class="string">"hello"</span>, Method);
}
NODE_MODULE(hello, init)</code></pre>
<p>Note that all Node.js addons must export an initialization function:</p>
<pre><code>void Initialize (Handle<span class="tag">&lt;<span class="title">Object</span>></span> target);
NODE_MODULE(module_name, Initialize)</code></pre>
<p>There is no semi-colon after <code>NODE_MODULE</code>, as it&#39;s not a function (for more
information, see <code>node.h</code>).</p>
<p>The source code needs to be built into <code>hello.node</code>, the binary Addon. To
do this we create a file called <code>binding.gyp</code> which describes the configuration
to build your module in a JSON-like format. This file gets compiled by
<a href="https://github.com/TooTallNate/node-gyp">node-gyp</a>.</p>
<pre><code>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"hello"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"hello.cc"</span> ]
    </span>}
  ]
</span>}</code></pre>
<p>The next step is to generate the appropriate project build files for the
current platform. Use <code>node-gyp configure</code> for that.</p>
<p>Now you will have either a <code>Makefile</code> (on Unix platforms) or a <code>vcxproj</code> file
(on Windows) in the <code>build/</code> directory. Next invoke the <code>node-gyp build</code>
command.</p>
<p>Now you have your compiled <code>.node</code> bindings file! The compiled bindings end up
in <code>build/Release/</code>.</p>
<p>You can now use the binary addon in a Node project <code>hello.js</code> by pointing <code>require</code> to
the recently built <code>hello.node</code> module:</p>
<pre><code><span class="keyword">var</span> addon = <span class="keyword">require</span>(<span class="string">'./build/Release/hello'</span>);

console.log(addon.hello()); <span class="comment">// 'world'</span></code></pre>
<p>Please see patterns below for further information or
<a href="https://github.com/arturadib/node-qt">https://github.com/arturadib/node-qt</a> for an example in production.</p>
<h2>Addon patterns</h2>
<p>Below are some addon patterns to help you get started. Consult the online
<a href="http://izs.me/v8-docs/main.html">v8 reference</a> for help with the various v8
calls, and v8&#39;s <a href="http://code.google.com/apis/v8/embed.html">Embedder&#39;s Guide</a>
for an explanation of several concepts used such as handles, scopes,
function templates, etc.</p>
<p>In order to use these examples you need to compile them using <code>node-gyp</code>.
Create the following <code>binding.gyp</code> file:</p>
<pre><code>{
  "<span class="attribute">targets</span>": <span class="value">[
    {
      "<span class="attribute">target_name</span>": <span class="value"><span class="string">"addon"</span></span>,
      "<span class="attribute">sources</span>": <span class="value">[ <span class="string">"addon.cc"</span> ]
    </span>}
  ]
</span>}</code></pre>
<p>In cases where there is more than one <code>.cc</code> file, simply add the file name to the
<code>sources</code> array, e.g.:</p>
<pre><code>"<span class="tag">sources</span>": <span class="attr_selector">["addon.cc", "myexample.cc"]</span></code></pre>
<p>Now that you have your <code>binding.gyp</code> ready, you can configure and build the
addon:</p>
<pre><code><span class="variable">$ </span>node-gyp configure build</code></pre>
<h3>Function arguments</h3>
<p>The following pattern illustrates how to read arguments from JavaScript
function calls and return a result. This is the main and only needed source
<code>addon.cc</code>:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">Add</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;

  if (args.Length() &lt; <span class="number">2</span>) {
    ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong number of arguments"</span>)));
    <span class="keyword">return</span> scope.Close(Undefined());
  }

  if (!args[<span class="number">0</span>]->IsNumber() || !args[<span class="number">1</span>]->IsNumber()) {
    ThrowException(Exception::TypeError(String::New(<span class="string">"Wrong arguments"</span>)));
    <span class="keyword">return</span> scope.Close(Undefined());
  }

  Local&lt;Number> num = Number::New(args[<span class="number">0</span>]->NumberValue() +
      args[<span class="number">1</span>]->NumberValue());
  <span class="keyword">return</span> scope.Close(num);
}

<span class="keyword">void</span> Init(Handle&lt;<span class="built_in">Object</span>> target) {
  target->Set(String::NewSymbol(<span class="string">"add"</span>),
      FunctionTemplate::New(Add)->GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>You can test it with the following JavaScript snippet:</p>
<pre><code>var addon = require(<span class="comment">'./build/Release/addon');</span>

console.<span class="built_in">log</span>( <span class="comment">'This should be eight:', addon.add(3,5) );</span></code></pre>
<h3>Callbacks</h3>
<p>You can pass JavaScript functions to a C++ function and execute them from
there. Here&#39;s <code>addon.cc</code>:</p>
<pre><code>#define BUILDING_NODE_EXTENSION
#include <span class="tag">&lt;<span class="title">node.h</span>></span>

using namespace v8;

Handle<span class="tag">&lt;<span class="title">Value</span>></span> RunCallback(const Arguments&amp; args) {
  HandleScope scope;

  Local<span class="tag">&lt;<span class="title">Function</span>></span> cb = Local<span class="tag">&lt;<span class="title">Function</span>></span>::Cast(args[0]);
  const unsigned argc = 1;
  Local<span class="tag">&lt;<span class="title">Value</span>></span> argv[argc] = { Local<span class="tag">&lt;<span class="title">Value</span>></span>::New(String::New("hello world")) };
  cb->Call(Context::GetCurrent()->Global(), argc, argv);

  return scope.Close(Undefined());
}

void Init(Handle<span class="tag">&lt;<span class="title">Object</span>></span> target) {
  target->Set(String::NewSymbol("runCallback"),
      FunctionTemplate::New(RunCallback)->GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>To test it run the following JavaScript snippet:</p>
<pre><code><span class="keyword">var</span> addon = require(<span class="string">'./build/Release/addon'</span>);

addon.runCallback(<span class="keyword">function</span>(msg){
  console.log(msg); <span class="comment">// 'hello world'</span>
});</code></pre>
<h3>Object factory</h3>
<p>You can create and return new objects from within a C++ function with this
<code>addon.cc</code> pattern, which returns an object with property <code>msg</code> that echoes
the string passed to <code>createObject()</code>:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">CreateObject</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;

  Local&lt;<span class="built_in">Object</span>> obj = <span class="built_in">Object</span>::New();
  obj->Set(String::NewSymbol(<span class="string">"msg"</span>), args[<span class="number">0</span>]->ToString());

  <span class="keyword">return</span> scope.Close(obj);
}

<span class="keyword">void</span> Init(Handle&lt;<span class="built_in">Object</span>> target) {
  target->Set(String::NewSymbol(<span class="string">"createObject"</span>),
      FunctionTemplate::New(CreateObject)->GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>To test it in JavaScript:</p>
<pre><code>var addon = require(<span class="comment">'./build/Release/addon');</span>

var obj1 = addon.<span class="built_in">createObject</span>(<span class="comment">'hello');</span>
var obj2 = addon.<span class="built_in">createObject</span>(<span class="comment">'world');</span>
console.<span class="built_in">log</span>(obj1.msg+<span class="comment">' '+obj2.msg); // 'hello world'</span></code></pre>
<h3>Function factory</h3>
<p>This pattern illustrates how to create and return a JavaScript function that
wraps a C++ function:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">MyFunction</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;
  <span class="keyword">return</span> scope.Close(String::New(<span class="string">"hello world"</span>));
}

Handle&lt;Value> CreateFunction(<span class="keyword">const</span> Arguments&amp; args) {
  HandleScope scope;

  Local&lt;FunctionTemplate> tpl = FunctionTemplate::New(MyFunction);
  Local&lt;Function> fn = tpl->GetFunction();
  fn->SetName(String::NewSymbol(<span class="string">"theFunction"</span>)); <span class="comment">// omit this to make it anonymous</span>

  <span class="keyword">return</span> scope.Close(fn);
}

<span class="keyword">void</span> Init(Handle&lt;<span class="built_in">Object</span>> target) {
  target->Set(String::NewSymbol(<span class="string">"createFunction"</span>),
      FunctionTemplate::New(CreateFunction)->GetFunction());
}

NODE_MODULE(addon, Init)</code></pre>
<p>To test:</p>
<pre><code>var addon = require(<span class="string">'./build/Release/addon'</span>);

var <span class="function"><span class="keyword">fn</span> = <span class="title">addon</span>.<span class="title">createFunction</span>(</span>);
console.<span class="keyword">log</span>(<span class="keyword">fn</span>()); <span class="comment">// 'hello world'</span></code></pre>
<h3>Wrapping C++ objects</h3>
<p>Here we will create a wrapper for a C++ object/class <code>MyObject</code> that can be
instantiated in JavaScript through the <code>new</code> operator. First prepare the main
module <code>addon.cc</code>:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>
<span class="preprocessor">#include "myobject.h"</span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">void</span> <span class="title">InitAll</span>(<span class="title">Handle</span>&lt;<span class="title">Object</span>> <span class="title">target</span>) {</span>
  MyObject::Init(target);
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>Then in <code>myobject.h</code> make your wrapper inherit from <code>node::ObjectWrap</code>:</p>
<pre><code><span class="preprocessor">#ifndef MYOBJECT_H</span>
<span class="preprocessor">#define MYOBJECT_H</span>

<span class="preprocessor">#include &lt;node.h></span>

<span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> : <span class="title">public</span> <span class="title">node</span>::<span class="title">ObjectWrap</span> {</span>
 <span class="keyword">public</span>:
  <span class="keyword">static</span> <span class="keyword">void</span> Init(v8::Handle&lt;v8::<span class="built_in">Object</span>> target);

 <span class="keyword">private</span>:
  MyObject();
  ~MyObject();

  <span class="keyword">static</span> v8::Handle&lt;v8::Value> New(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> PlusOne(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">double</span> counter_;
};

<span class="preprocessor">#endif</span></code></pre>
<p>And in <code>myobject.cc</code> implement the various methods that you want to expose.
Here we expose the method <code>plusOne</code> by adding it to the constructor&#39;s
prototype:</p>
<pre><code><span class="comment">#define BUILDING_NODE_EXTENSION</span>
<span class="comment">#include &lt;node.h></span>
<span class="comment">#include "myobject.h"</span>

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

void MyObject::Init(Handle&lt;Object> target) {
  <span class="regexp">//</span> Prepare constructor template
  Local&lt;FunctionTemplate> tpl = FunctionTemplate::New(New);
  tpl->SetClassName(String::NewSymbol(<span class="string">"MyObject"</span>));
  tpl->InstanceTemplate()->SetInternalFieldCount(<span class="number">1</span>);
  <span class="regexp">//</span> Prototype
  tpl->PrototypeTemplate()->Set(String::NewSymbol(<span class="string">"plusOne"</span>),
      FunctionTemplate::New(PlusOne)->GetFunction());

  Persistent&lt;Function> constructor = Persistent&lt;Function>::New(tpl->GetFunction());
  target->Set(String::NewSymbol(<span class="string">"MyObject"</span>), constructor);
}

Handle&lt;Value> MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj->counter_ = args[<span class="number">0</span>]->IsUndefined() ? <span class="number">0</span> : args[<span class="number">0</span>]->NumberValue();
  obj->Wrap(args.This());

  <span class="keyword">return</span> args.This();
}

Handle&lt;Value> MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject>(args.This());
  obj->counter_ += <span class="number">1</span>;

  <span class="keyword">return</span> scope.Close(Number::New(obj->counter_));
}</code></pre>
<p>Test it with:</p>
<pre><code><span class="keyword">var</span> addon = <span class="keyword">require</span>(<span class="string">'./build/Release/addon'</span>);

<span class="keyword">var</span> obj = <span class="keyword">new</span> addon.MyObject(<span class="number">10</span>);
console.log( obj.plusOne() ); <span class="comment">// 11</span>
console.log( obj.plusOne() ); <span class="comment">// 12</span>
console.log( obj.plusOne() ); <span class="comment">// 13</span></code></pre>
<h3>Factory of wrapped objects</h3>
<p>This is useful when you want to be able to create native objects without
explicitly instantiating them with the <code>new</code> operator in JavaScript, e.g.</p>
<pre><code><span class="reserved">var</span> obj = addon.createObject();
<span class="regexp">//</span> instead <span class="keyword">of</span>:
<span class="regexp">//</span> <span class="reserved">var</span> obj = <span class="keyword">new</span> addon.Object();</code></pre>
<p>Let&#39;s register our <code>createObject</code> method in <code>addon.cc</code>:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>
<span class="preprocessor">#include "myobject.h"</span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">CreateObject</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;
  <span class="keyword">return</span> scope.Close(MyObject::NewInstance(args));
}

<span class="keyword">void</span> InitAll(Handle&lt;<span class="built_in">Object</span>> target) {
  MyObject::Init();

  target->Set(String::NewSymbol(<span class="string">"createObject"</span>),
      FunctionTemplate::New(CreateObject)->GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>In <code>myobject.h</code> we now introduce the static method <code>NewInstance</code> that takes
care of instantiating the object (i.e. it does the job of <code>new</code> in JavaScript):</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#ifndef MYOBJECT_H</span>
<span class="preprocessor">#define MYOBJECT_H</span>

<span class="preprocessor">#include &lt;node.h></span>

<span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> : <span class="title">public</span> <span class="title">node</span>::<span class="title">ObjectWrap</span> {</span>
 <span class="keyword">public</span>:
  <span class="keyword">static</span> <span class="keyword">void</span> Init();
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> NewInstance(<span class="keyword">const</span> v8::Arguments&amp; args);

 <span class="keyword">private</span>:
  MyObject();
  ~MyObject();

  <span class="keyword">static</span> v8::Persistent&lt;v8::Function> constructor;
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> New(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> PlusOne(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">double</span> counter_;
};

<span class="preprocessor">#endif</span></code></pre>
<p>The implementation is similar to the above in <code>myobject.cc</code>:</p>
<pre><code><span class="comment">#define BUILDING_NODE_EXTENSION</span>
<span class="comment">#include &lt;node.h></span>
<span class="comment">#include "myobject.h"</span>

using namespace v8;

MyObject::MyObject() {};
MyObject::~MyObject() {};

Persistent&lt;Function> MyObject::constructor;

void MyObject::Init() {
  <span class="regexp">//</span> Prepare constructor template
  Local&lt;FunctionTemplate> tpl = FunctionTemplate::New(New);
  tpl->SetClassName(String::NewSymbol(<span class="string">"MyObject"</span>));
  tpl->InstanceTemplate()->SetInternalFieldCount(<span class="number">1</span>);
  <span class="regexp">//</span> Prototype
  tpl->PrototypeTemplate()->Set(String::NewSymbol(<span class="string">"plusOne"</span>),
      FunctionTemplate::New(PlusOne)->GetFunction());

  constructor = Persistent&lt;Function>::New(tpl->GetFunction());
}

Handle&lt;Value> MyObject::New(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = new MyObject();
  obj->counter_ = args[<span class="number">0</span>]->IsUndefined() ? <span class="number">0</span> : args[<span class="number">0</span>]->NumberValue();
  obj->Wrap(args.This());

  <span class="keyword">return</span> args.This();
}

Handle&lt;Value> MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope;

  const unsigned argc = <span class="number">1</span>;
  Handle&lt;Value> argv[argc] = { args[<span class="number">0</span>] };
  Local&lt;Object> instance = constructor->NewInstance(argc, argv);

  <span class="keyword">return</span> scope.Close(instance);
}

Handle&lt;Value> MyObject::PlusOne(const Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj = ObjectWrap::Unwrap&lt;MyObject>(args.This());
  obj->counter_ += <span class="number">1</span>;

  <span class="keyword">return</span> scope.Close(Number::New(obj->counter_));
}</code></pre>
<p>Test it with:</p>
<pre><code>var addon = require(<span class="string">'./build/Release/addon'</span>);

var obj = addon.createObject(<span class="number">10</span>);
console.<span class="keyword">log</span>( obj.plusOne() ); <span class="comment">// 11</span>
console.<span class="keyword">log</span>( obj.plusOne() ); <span class="comment">// 12</span>
console.<span class="keyword">log</span>( obj.plusOne() ); <span class="comment">// 13</span>

var obj2 = addon.createObject(<span class="number">20</span>);
console.<span class="keyword">log</span>( obj2.plusOne() ); <span class="comment">// 21</span>
console.<span class="keyword">log</span>( obj2.plusOne() ); <span class="comment">// 22</span>
console.<span class="keyword">log</span>( obj2.plusOne() ); <span class="comment">// 23</span></code></pre>
<h3>Passing wrapped objects around</h3>
<p>In addition to wrapping and returning C++ objects, you can pass them around
by unwrapping them with Node&#39;s <code>node::ObjectWrap::Unwrap</code> helper function.
In the following <code>addon.cc</code> we introduce a function <code>add()</code> that can take on two
<code>MyObject</code> objects:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>
<span class="preprocessor">#include "myobject.h"</span>

<span class="keyword">using</span> <span class="class"><span class="keyword">namespace</span> <span class="title">v8</span>;

<span class="title">Handle</span>&lt;<span class="title">Value</span>> <span class="title">CreateObject</span>(<span class="title">const</span> <span class="title">Arguments</span>&amp; <span class="title">args</span>) {</span>
  HandleScope scope;
  <span class="keyword">return</span> scope.Close(MyObject::NewInstance(args));
}

Handle&lt;Value> Add(<span class="keyword">const</span> Arguments&amp; args) {
  HandleScope scope;

  MyObject* obj1 = node::ObjectWrap::Unwrap&lt;MyObject>(
      args[<span class="number">0</span>]->ToObject());
  MyObject* obj2 = node::ObjectWrap::Unwrap&lt;MyObject>(
      args[<span class="number">1</span>]->ToObject());

  <span class="keyword">double</span> sum = obj1->Val() + obj2->Val();
  <span class="keyword">return</span> scope.Close(Number::New(sum));
}

<span class="keyword">void</span> InitAll(Handle&lt;<span class="built_in">Object</span>> target) {
  MyObject::Init();

  target->Set(String::NewSymbol(<span class="string">"createObject"</span>),
      FunctionTemplate::New(CreateObject)->GetFunction());

  target->Set(String::NewSymbol(<span class="string">"add"</span>),
      FunctionTemplate::New(Add)->GetFunction());
}

NODE_MODULE(addon, InitAll)</code></pre>
<p>To make things interesting we introduce a public method in <code>myobject.h</code> so we
can probe private values after unwrapping the object:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#ifndef MYOBJECT_H</span>
<span class="preprocessor">#define MYOBJECT_H</span>

<span class="preprocessor">#include &lt;node.h></span>

<span class="class"><span class="keyword">class</span> <span class="title">MyObject</span> : <span class="title">public</span> <span class="title">node</span>::<span class="title">ObjectWrap</span> {</span>
 <span class="keyword">public</span>:
  <span class="keyword">static</span> <span class="keyword">void</span> Init();
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> NewInstance(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">double</span> Val() <span class="keyword">const</span> { <span class="keyword">return</span> val_; }

 <span class="keyword">private</span>:
  MyObject();
  ~MyObject();

  <span class="keyword">static</span> v8::Persistent&lt;v8::Function> constructor;
  <span class="keyword">static</span> v8::Handle&lt;v8::Value> New(<span class="keyword">const</span> v8::Arguments&amp; args);
  <span class="keyword">double</span> val_;
};

<span class="preprocessor">#endif</span></code></pre>
<p>The implementation of <code>myobject.cc</code> is similar as before:</p>
<pre><code><span class="preprocessor">#define BUILDING_NODE_EXTENSION</span>
<span class="preprocessor">#include &lt;node.h></span>
<span class="preprocessor">#include "myobject.h"</span>

using namespace v8<span class="comment">;</span>

<span class="label">MyObject:</span>:MyObject() {}<span class="comment">;</span>
<span class="label">MyObject:</span>:~MyObject() {}<span class="comment">;</span>

Persistent&lt;Function> MyObject::constructor<span class="comment">;</span>

void MyObject::Init() {
  // Prepare constructor template
  Local&lt;FunctionTemplate> tpl = FunctionTemplate::New(New)<span class="comment">;</span>
  tpl->SetClassName(String::NewSymbol(<span class="string">"MyObject"</span>))<span class="comment">;</span>
  tpl->InstanceTemplate()->SetInternalFieldCount(<span class="number">1</span>)<span class="comment">;</span>

  constructor = Persistent&lt;Function>::New(tpl->GetFunction())<span class="comment">;</span>
}

Handle&lt;Value> MyObject::New(const Arguments&amp; args) {
  HandleScope scope<span class="comment">;</span>

  MyObject* obj = new MyObject()<span class="comment">;</span>
  obj->val_ = args[<span class="number">0</span>]->IsUndefined() ? <span class="number">0</span> : args[<span class="number">0</span>]->NumberValue()<span class="comment">;</span>
  obj->Wrap(args<span class="preprocessor">.This</span>())<span class="comment">;</span>

  return args<span class="preprocessor">.This</span>()<span class="comment">;</span>
}

Handle&lt;Value> MyObject::NewInstance(const Arguments&amp; args) {
  HandleScope scope<span class="comment">;</span>

  const unsigned argc = <span class="number">1</span><span class="comment">;</span>
  Handle&lt;Value> argv[argc] = { args[<span class="number">0</span>] }<span class="comment">;</span>
  Local&lt;Object> instance = constructor->NewInstance(argc, argv)<span class="comment">;</span>

  return scope<span class="preprocessor">.Close</span>(instance)<span class="comment">;</span>
}</code></pre>
<p>Test it with:</p>
<pre><code><span class="keyword">var</span> addon = <span class="keyword">require</span>(<span class="string">'./build/Release/addon'</span>);

<span class="keyword">var</span> obj1 = addon.createObject(<span class="number">10</span>);
<span class="keyword">var</span> obj2 = addon.createObject(<span class="number">20</span>);
<span class="keyword">var</span> result = addon.add(obj1, obj2);

console.log(result); <span class="comment">// 30</span></code></pre>
</div></div></article></div></div><div id="disqus_thread"></div></div></div></div></div><div class="push"></div></div><div id="footer"><div class="footerInner"><div class="footer-text">&#169; 2012:</div></div></div><!-- scripts concatenated and minified via ant build script--><script defer src="./assets/javascripts/plugins.js"></script>
<script defer src="./assets/javascripts/prettify.js"></script>
<script defer src="./assets/javascripts/prettify-extension.js"></script>
<script defer src="./assets/javascripts/ux.js"></script><!-- end scripts--><!--[if lt IE 7]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
</script><![endif]--></body></html>