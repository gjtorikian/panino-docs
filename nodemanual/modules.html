<!DOCTYPE html><!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]> <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]> <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]--><html xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Node.js Manual TEST - </title><meta name="generator" content="panino-doc-build"><meta name="author" content="Garen J. Torikian"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="stylesheet" href="./assets/csses/bootstrap.min.css"><link rel="stylesheet" href="./assets/csses/prettify.css"><link rel="stylesheet" href="./assets/csses/refguide_overrides.css"><link href="./assets/images/favicon.ico" rel="icon" type="image/x-icon"><link type="text/css" rel="stylesheet" href="http://yandex.st/highlightjs/6.1/styles/vs.min.css"><script src="./assets/javascripts/jquery.js"></script><script src="./assets/javascripts/clicker.js"></script><script src="./assets/javascripts/jquery.collapse.js"></script><script src="./assets/javascripts/jquery.cookie.js"></script><script src="./assets/javascripts/bootstrap-dropdown.js"></script><script src="./assets/javascripts/jquery-scrollspy.js"></script><script src="./assets/javascripts/prettify-extension.js"></script></head><body><div class="navbar navbar-fixed-top"><div class="navbar-inner"><div id="topSection" class="container"><ul class="nav topLinks"></ul><form id="searchbox" action="" class="navbar-search pull-right"> <input name="query" type="text" placeholder="Search the API" title="Search across all the documentation" class="search-query span3"></form></div></div></div><div id="nonFooter"><div id="wrapper"><div class="content"><div class="row centerpiece"><div id="sidebarContainer" class="span3"><div id="sidebar"><!--include _menu.jade--></div></div><div id="mainContent" class="span9"><div id="documentation"><div class="classContent"><div class="membersBackground"></div><div class=" members pos0"><div class=" membersContent pos0"><h1 class="memberHeader"><span class="name">Modules</span></h1><ul data-tabs="tabs" class="nav tabs pos0"><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li><li data-dropdown="dropdown" class="dropdown"><ul class="dropdown-menu"></ul></li></ul></div></div><article id="Modules" data-title="Modules (class)" class="article"><blockquote>
<p>5 - Locked</p>
</blockquote>
<div class="section description"><div class="memberContent"><p>Node.js has a simple module loading system. In Node.js, files and modules are in
one-to-one correspondence.</p>
<p>For example, imagine a scenario where <code>foo.js</code> loads the module <code>circle.js</code> in
the same directory.</p>
<p>The contents of <code>foo.js</code> are:</p>
<pre><code>var circle = require('./circle.js');
console.log( <span class="attribute">'The</span> area <span class="keyword">of</span> a circle <span class="keyword">of</span> radius <span class="number">4</span> <span class="keyword">is</span> '
           + circle.area(<span class="number">4</span>));</code></pre>
<p>The contents of <code>circle.js</code> are:</p>
<pre><code><span class="keyword">var</span> PI = Math.PI;

exports.area = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> {</span>
  <span class="keyword">return</span> PI * r * r;
};

exports.circumference = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> {</span>
  <span class="keyword">return</span> <span class="number">2</span> * PI * r;
};</code></pre>
<p>The module <code>circle.js</code> has exported the functions <code>area()</code> and
<code>circumference()</code>.  To export an object, add to the special
<a href="#module.exports"><code>exports</code></a> object.</p>
<p>Variables local to a module are private. In this example, the variable <code>PI</code> is
private to <code>circle.js</code>.</p>
<h4>Cycles</h4>
<p>Whenever there are circular <code>require()</code> calls, a module might not be done being
executed when it is returned.</p>
<p>Consider this situation with the following files. In `a.js&#39;:</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'a starting');</span>
exports.done = <span class="literal">false</span>;
var b = require(<span class="comment">'./b.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in a, b.done = %j', b.done);</span>
exports.done = <span class="literal">true</span>;
console.<span class="built_in">log</span>(<span class="comment">'a done');</span></code></pre>
<p>In <code>b.js</code>:</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'b starting');</span>
exports.done = <span class="literal">false</span>;
var a = require(<span class="comment">'./a.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in b, a.done = %j', a.done);</span>
exports.done = <span class="literal">true</span>;
console.<span class="built_in">log</span>(<span class="comment">'b done');</span></code></pre>
<p>And in <code>main.js</code>:</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'main starting');</span>
var a = require(<span class="comment">'./a.js');</span>
var b = require(<span class="comment">'./b.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in main, a.done=%j, b.done=%j', a.done, b.done);</span></code></pre>
<p>When <code>main.js</code> loads <code>a.js</code>, <code>a.js</code> loads <code>b.js</code>. At that point, <code>b.js</code> tries to
load <code>a.js</code>.  In order to prevent an infinite loop an &quot;unfinished copy&quot; of the
<code>a.js</code> exports object is returned to the <code>b.js</code> module.  <code>b.js</code> then finishes
loading, and its exports object is provided to the <code>a.js</code> module.</p>
<p>By the time <code>main.js</code> finishes loading both modules, they&#39;ve both finished
executing. The output of this program would thus be:</p>
<pre><code>$ node main.js
main starting
a starting
b starting
<span class="keyword">in</span> b, a.<span class="keyword">done</span> = <span class="literal">false</span>
b <span class="keyword">done</span>
<span class="keyword">in</span> a, b.<span class="keyword">done</span> = <span class="literal">true</span>
a <span class="keyword">done</span>
<span class="keyword">in</span> main, a.<span class="keyword">done</span>=<span class="literal">true</span>, b.<span class="keyword">done</span>=<span class="literal">true</span></code></pre>
<p>If you have cyclic module dependencies in your program, make sure to plan
accordingly.</p>
<h4>Core Modules</h4>
<p>Node.js has several modules compiled into the binary. These modules are
described in greater detail elsewhere in this documentation.</p>
<p>The core modules are defined in Node&#39;s source in the <code>lib/</code> folder.</p>
<p>Core modules are always preferentially loaded if their identifier is passed to
<code>require()</code>.  For instance, <code>require(&#39;http&#39;)</code> always returns the built in HTTP
module, even if there is a file by that name.</p>
<h4>File Modules</h4>
<p>If the exact filename is not found, then Node.js attempts to load the required
filename with the added extension of <code>.js</code>, <code>.json</code>, and then <code>.node</code>.</p>
<p><code>.js</code> files are interpreted as Javascript text files, and <code>.json</code> files are
parsed as JSON text files. <code>.node</code> files are interpreted as compiled addon
modules loaded with <code>dlopen</code>.</p>
<p>A module prefixed with <code>&#39;/&#39;</code> is an absolute path to the file.  For example,
<code>require(&#39;/home/marco/foo.js&#39;)</code> loads the file at <code>/home/marco/foo.js</code>.</p>
<p>A module prefixed with <code>&#39;./&#39;</code> is relative to the file calling <code>require()</code>. That
is, <code>circle.js</code> must be in the same directory as <code>foo.js</code> for
<code>require(&#39;./circle&#39;)</code> to find it.</p>
<p>Without a leading <code>&#39;/&#39;</code> or <code>&#39;./&#39;</code> to indicate a file, the module is either a
&quot;core module&quot; or is loaded from the <code>node_modules</code> folder.</p>
<p>For example, if the file at <code>&#39;/home/ry/projects/foo.js&#39;</code> is called by
<code>require(&#39;bar.js&#39;)</code>, then Node.js looks for it in the following locations, in
this order:</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>This allows programs to localize their dependencies, so that they don&#39;t clash.</p>
<p>If the given path does not exist, <code>require()</code> throws an Error with its
<code>code</code> property set to <code>&#39;MODULE_NOT_FOUND&#39;</code>.</p>
<h4>Folders as Modules</h4>
<p>It is convenient to organize programs and libraries into self-contained
directories, and then provide a single entry point to that library.</p>
<p>There are three ways in which a folder may be passed to <code>require()</code> as an
argument.</p>
<p>The first is to create a <code>package.json</code> file in the root of the folder, which
specifies a <code>main</code> module.  An example <code>package.json</code> file might look like this:</p>
<pre><code>{ "<span class="attribute">name</span>" : <span class="value"><span class="string">"some-library"</span></span>,
  "<span class="attribute">main</span>" : <span class="value"><span class="string">"./lib/some-library.js"</span> </span>}</code></pre>
<p>If this was in a folder at <code>./some-library</code>, then <code>require(&#39;./some-library&#39;)</code>
would attempt to load <code>./some-library/lib/some-library.js</code>.</p>
<p>This is the extent of Node&#39;s awareness of <code>package.json</code> files.</p>
<p>If there is no <code>package.json</code> file present in the directory, then Node.js
attempts to load an <code>index.js</code> or <code>index.node</code> file out of that directory.  For
example, if there was no <code>package.json</code> file in the above example, then
<code>require(&#39;./some-library&#39;)</code> would attempt to load:</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h4>Caching</h4>
<p>Modules are cached after the first time they are loaded.  This means (among
other things) that every call to <code>require(&#39;foo&#39;)</code> gets exactly the same object
returned, if it would resolve to the same file.</p>
<p>Multiple calls to <code>require(&#39;foo&#39;)</code> may not cause the module code to be executed
multiple times.  This is an important feature.  With it, &quot;partially done&quot;
objects can be returned, thus allowing transitive dependencies to be loaded even
when they would cause cycles.</p>
<p>If you want to have a module execute code multiple times, then export a
function, and call that function.</p>
<h4>Module Caching Caveats</h4>
<p>Modules are cached based on their resolved filename.  Since modules may resolve
to a different filename based on the location of the calling module (loading
from <code>node_modules</code> folders), it is not a guarantee that <code>require(&#39;foo&#39;)</code> always
returns the exact same object, if it would resolve to different files.</p>
<h4>The <code>module</code> Object</h4>
<p>In each module, the <code>module</code> variable is a reference to the object representing
the current module. In particular, <code>module.exports</code> is the same as the <code>exports</code>
object.</p>
<p><code>module</code> isn&#39;t actually a global, but rather local to each module.</p>
<p><a id="module.exports"></a></p>
<p>The <code>exports</code> object is created by the Module system. Sometimes, this is not
acceptable, as some developers want their module to be an instance of some
class.</p>
<p>To do this assign the desired export object to <code>module.exports</code>. For example
suppose we were making a module called <code>a.js</code></p>
<pre><code>var <span class="variable">EventEmitter</span> = require('events').<span class="variable">EventEmitter</span>;

module.exports = new <span class="variable">EventEmitter</span>();

// <span class="variable">Do</span> some work, <span class="keyword">and</span> <span class="keyword">after</span> some time emit
// the 'ready' event from the module itself.
<span class="function"><span class="title">setTimeout</span><span class="params">(<span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{
  module.exports.<span class="function_name">emit</span>('ready');
}</span>, <span class="number">1000</span>);</code></pre>
<p>Then, in another file we could do</p>
<pre><code>var a = require(<span class="comment">'./a');</span>
a.<span class="keyword">on</span>(<span class="comment">'ready', function() {</span>
  console.<span class="built_in">log</span>(<span class="comment">'module a is ready');</span>
});</code></pre>
<p>Note that the assignment to <code>module.exports</code> must be done immediately. It can&#39;t
be done in any callbacks. For example, this does not work:</p>
<p>In a file called <code>x.js</code>:</p>
<pre><code><span class="function"><span class="title">setTimeout</span><span class="params">(<span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{
  module.exports = <span class="tuple">{ a: <span class="string">"hello"</span> }</span>;
}</span>, <span class="number">0</span>);</code></pre>
<p>In a file called <code>y.js</code>:</p>
<pre><code><span class="keyword">var</span> x = <span class="keyword">require</span>(<span class="string">'./x'</span>);
console.log(x.a);</code></pre>
<h4>All Together Now</h4>
<p>To get the exact filename that will be loaded when <code>require()</code> is called, use
the <code>require.resolve()</code> function.</p>
<p>Putting together all of the above, here is the high-level algorithm (in
pseudocode) of what <code>require.resolve()</code> does:</p>
<p><dl>
<dt>To <code>require(X)</code> from module at path Y:</dt></p>
<dd>
    <pre>
    1. If X is a core module,
        a. return the core module
        b. STOP
    2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;
        a. LOAD_AS_FILE(Y + X)
        b. LOAD_AS_DIRECTORY(Y + X)
    3. LOAD_NODE_MODULES(X, dirname(Y))
    4. THROW &quot;not found&quot;
    </pre>
</dd>
<dt>To <code>LOAD_AS_FILE(X)</code>:</dt>
<dd>
    <pre>
    1. If X is a file, load X as Javascript text.  STOP
    2. If X.js is a file, load X.js as Javascript text.  STOP
    3. If X.node is a file, load X.node as binary addon.  STOP
    </pre>
<dd>
<dt>To <code>LOAD_AS_DIRECTORY(X)</code>:</dt>
<dd>
    <pre>
    1. If X/package.json is a file,
       a. Parse X/package.json, and look for &quot;main&quot; field.
       b. let M = X + (json main field)
       c. LOAD_AS_FILE(M)
    2. If X/index.js is a file, load X/index.js as Javascript text.  STOP
    3. If X/index.node is a file, load X/index.node as binary addon.  STOP
    </pre>
</dd>
<dt>To <code>LOAD_NODE_MODULES(X, START)</code>: </dt>
<dd>
    <pre>
    1. let DIRS=NODE_MODULES_PATHS(START)
    2. for each DIR in DIRS:
       a. LOAD_AS_FILE(DIR/X)
       b. LOAD_AS_DIRECTORY(DIR/X)
    </pre>
</dd>
<dt>To <code>NODE_MODULES_PATHS(START)</code>: </dt>
<dd>
    <pre>
    1. let PARTS = path split(START)
    2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
    3. let I = count of PARTS - 1
    4. let DIRS = []
    5. while I &gt; ROOT,
       a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
       c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
       b. DIRS = DIRS + DIR
       c. let I = I - 1
    6. return DIRS
    </pre>
</dd>

<h4>Loading from the global folders</h4>
<p>If the <code>NODE_PATH</code> environment variable is set to a colon-delimited list of
absolute paths, then Node.js searches those paths for modules if they are not
found elsewhere. (Note: On Windows, <code>NODE_PATH</code> is delimited by semicolons
instead of colons.)</p>
<p>Additionally, Node.js searches in the following locations:</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li></li>
</ul>
<p>Where <code>$HOME</code> is the user&#39;s home directory, and <code>$PREFIX</code> is Node&#39;s configured
<code>node_prefix</code>.</p>
<p>These are mostly for historic reasons. You are highly encouraged to place your
dependencies locally in <code>node_modules</code> folders.  They will be loaded faster, and
more reliably.</p>
<h4>Accessing the <code>main</code> module</h4>
<p>When a file is run directly from Node.js, <code>require.main</code> is set to its <code>module</code>.
That means that you can determine whether a file has been run directly by
testing for the following:</p>
<pre><code><span class="title">require</span>.main === <span class="module"><span class="keyword">module</span></code></pre>
<p>For a file <code>foo.js</code>, this is <code>true</code> if run via <code>node foo.js</code>, but <code>false</code> if run
by <code>require(&#39;./foo&#39;)</code>.</p>
<p>Because <code>module</code> provides a <code>filename</code> property (normally equivalent to
<code>__filename</code>), the entry point of the current application can be obtained by
checking <code>require.main.filename</code>.</p>
<h4>Package Manager Tips</h4>
<p>The semantics of Node&#39;s <code>require()</code> function were designed to be general enough
to support a number of sane directory structures. Package manager programs such
as <code>dpkg</code>, <code>rpm</code>, and <code>npm</code> will hopefully find it possible to build native
packages from Node modules without modification.</p>
<p>Below we give a suggested directory structure that could work:</p>
<p>Let&#39;s say that we wanted to have the folder at
<code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code> hold the contents of a specific
version of a package.</p>
<p>Packages can depend on one another. In order to install package <code>foo</code>, you may
have to install a specific version of package <code>bar</code>.  The <code>bar</code> package may
itself have dependencies, and in some cases, these dependencies may even collide
or form cycles.</p>
<p>Since Node.js looks up the <code>realpath</code> of any modules it loads (that is, resolves
symlinks), and then looks for their dependencies in the <code>node_modules</code> folders
as described above, this situation is very simple to resolve with the following
architecture:</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - Contents of the <code>foo</code> package, version 1.2.3.</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - Contents of the <code>bar</code> package that <code>foo</code> depends
on.</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - Symbolic link to
<code>/usr/lib/node/bar/4.3.2/</code>.</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - Symbolic links to the packages that
<code>bar</code> depends on.</li>
</ul>
<p>Thus, even if a cycle is encountered, or if there are dependency conflicts,
every module will be able to get a version of its dependency that it can use.</p>
<p>When the code in the <code>foo</code> package does <code>require(&#39;bar&#39;)</code>, it gets the version
that is symlinked into <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>. Then, when
the code in the <code>bar</code> package calls <code>require(&#39;quux&#39;)</code>, it gets the version that
is symlinked into <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>.</p>
<p>Furthermore, to make the module lookup process even more optimal, rather than
putting packages directly in <code>/usr/lib/node</code>, we could put them in
<code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>.  Then Node.js doesn&#39;t bother looking
for missing dependencies in <code>/usr/node_modules</code> or <code>/node_modules</code>.</p>
<p>In order to make modules available to the Node.js REPL, it might be useful to
also add the <code>/usr/lib/node_modules</code> folder to the <code>$NODE_PATH</code> environment
variable.  Since the module lookups using <code>node_modules</code> folders are all
relative, and based on the real path of the files making the calls to
<code>require()</code>, the packages themselves can be anywhere.</p>
</div></div></article></div></div><div id="disqus_thread"></div></div></div></div></div><div class="push"></div></div><div id="footer"><div class="footerInner"><div class="footer-text">&#169; 2012:</div></div></div><!-- scripts concatenated and minified via ant build script--><script defer src="./assets/javascripts/plugins.js"></script>
<script defer src="./assets/javascripts/prettify.js"></script>
<script defer src="./assets/javascripts/prettify-extension.js"></script>
<script defer src="./assets/javascripts/ux.js"></script><!-- end scripts--><!--[if lt IE 7]><script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script><script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})
</script><![endif]--></body></html>